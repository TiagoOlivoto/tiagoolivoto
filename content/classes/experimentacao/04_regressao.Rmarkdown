---
title: Regressão linear
linktitle: "4. Regressão linear"
toc: true
type: docs
date: "2022/03/03"
draft: false
df_print: paged
code_download: true
menu:
  experimentacao:
    parent: Experimentação
    weight: 5
weight: 4
---

# Pacotes
```{r collapse = FALSE, message=FALSE, warning=FALSE}
library(tidyverse)
library(metan)      # estatísticas descritivas
library(rio)        # importação/exportação de dados
library(AgroR)
library(broom)
```

# Introdução

A análise de regressão tem como objetivo verificar como uma variável independente influencia a resposta de uma variável dependente. A análise de regressão é amplamente utilizada nas ciências agrárias. O modelo mais simples de regressão linear é a de primeiro grau, descrita conforme o modelo a seguir:

$$
Y_i = {\beta _0} + {\beta _1}x + \varepsilon_i  
$$

Onde \$Y_i\$ é a variável dependente, \$x\$ é a variável independente, \$\beta_0\$ é o intercepto, \$\beta_1\$ é a inclinação da reta e \$\varepsilon\$ é o desvio. 



# Regressão linear (dados sem repetições)

Neste exemplo, 

```{r}
# definir tema
theme_set(theme_gray(base_size = 14) +
            theme(panel.grid.minor = element_blank()))

DOSEN <- seq(0, 150, by = 25)
RG <- c(8.6, 8.9, 9.5, 9.9, 10, 10.2, 10.5)
df <- data.frame(DOSEN = DOSEN, RG = RG)

# ajustar modelo de regressão linear
mod <- lm(RG ~ DOSEN, data = df)

# gráfico base
p0 <- ggplot(df, aes(DOSEN, RG))

# pontos plotados
p0 + 
  geom_point(size = 4, color = "red") +
  scale_x_continuous(breaks = DOSEN) +
  labs(x = "Dose de N (Kg/ha)",
       y= "Rendimento de grãos (t/ha)")

# diversos modelos
p0 + 
  geom_point(size = 4, color = "red") +
  geom_abline(intercept = 9, slope = 0.01, color = "red") +
  geom_abline(intercept = 8.5, slope = 0.015, color = "blue") +
  geom_smooth(se = FALSE, method = "lm") +
  geom_abline(intercept = 8.7, slope = 0.012, color = "green") +
  geom_abline(intercept = 9.1, slope = 0.008, color = "black") +
  scale_x_continuous(breaks = DOSEN) +
  labs(x = "Dose de N (Kg/ha)",
       y= "Rendimento de grãos (t/ha)")

# modelo ajustado com resíduos
p0 +
  geom_segment(aes(x = DOSEN, y = RG, xend = DOSEN, yend = fitted(mod))) +
  geom_point(size = 4, color = "red") + 
  geom_smooth(se = FALSE, method = "lm") +
  scale_x_continuous(breaks = DOSEN) +
  labs(x = "Dose de N (Kg/ha)",
       y= "Rendimento de grãos (t/ha)")


# valores preditos
pred <- 
  df %>% 
  mutate(predito = predict(mod),
         residual = RG - predito)
pred



# modelo ajustado o valor predito para x = 75
# função auxiliar
pred_linear <- function(mod, x){
  b0 <- coef(mod)[[1]]
  b1 <- coef(mod)[[2]]
  pred <- b0 + b1 * x
  return(pred)
}

pred_75 <- pred_linear(mod, 75)
pred_75

p0 +
  geom_smooth(se = FALSE, method = "lm") +
  geom_segment(aes(x = 75, y = 8.5, xend = 75, yend = pred_75)) +
  geom_segment(aes(x = 0, y = pred_75, xend = 75, yend = pred_75)) +
  geom_point(aes(x = 75, y = pred_75), color = "blue", size = 4) +
  geom_point(size = 4, color = "red") + 
  scale_x_continuous(breaks = DOSEN) +
  labs(x = "Dose de N (Kg/ha)",
       y= "Rendimento de grãos (t/ha)",
       title = "Reta predita para o modelo de regressão",
       subtitle = "O ponto azul representa o RG predito com 75 kg/ha de N")
```



# Regressão linear (com repetições)
```{r}
url <- "http://bit.ly/df_biostat_exp"
df_reg <- import(url, sheet = "REG_DEL_DATA", setclass = "tbl")


# anova em DBC
df_factors <- df_reg %>% as_factor(1:2)
anova <- aov(RG ~ DOSEN + BLOCO, data = df_factors)
tidy(anova) %>% as.data.frame()


# regressão
reg <- lm(RG ~ DOSEN, data = df_reg)
tidy(reg) %>% as.data.frame()


# anova da regressão
anova_reg <- aov(reg)
tidy(anova_reg) %>% as.data.frame() %>% slice(1)



p0 <- ggplot(df_reg, aes(DOSEN, RG))

# pontos plotados
p0 + 
  geom_point(color = "red") +
  stat_summary(geom = "point",
               fun = mean,
               shape = 23) +
  labs(x = "Dose de N (Kg/ha)",
       y = "Rendimento de grãos (t/ha)") +
  geom_smooth(method = "lm", se = FALSE)

```


# Polinômio de segundo grau

A regressão polinomial de segundo grau (que também é linear!) é uma outra opção muito útil para analisar dados que apresentem comportamento de parábola, por vezes observado em ensaios que testam dosagens de algum produto/fertilizante, etc. Neste tipo, um parâmetro a mais é adicionado ao modelo, ficando na forma:

$$
Y_i = {\beta _0} + {\beta _1}x + {\beta _2}x^2 + \varepsilon_i  
$$

Como motivação, utilizaremos os dados abaixo. Para ajustar um modelo polinomial, utilizamos a função `poly()` e informamos o grau do polinômio desejado. É válido lembrar, que o grau máximo possível de polinômio é dado pelo número de níveis da variável independente/preditora menos 1.

```{r}
DOSEN <- c(0, 50, 100, 150, 200, 250)
RG    <- c(7.1, 7.3, 7.66, 7.71, 7.62, 7.6)
df2 <- data.frame(DOSEN = DOSEN, RG = RG)

# modelo de regressão
mod2 <- lm(RG ~ poly(DOSEN, 2, raw = TRUE), data = df2)
summary(mod2)

# valores preditos
pred2 <- 
  df2 %>% 
  mutate(predito = predict(mod2),
         residual = RG - predito)
pred2


# gráfico base
p1 <-
  ggplot(df2, aes(DOSEN, RG)) +
  geom_point(size = 4, color = "red") + 
  geom_smooth(se = FALSE,
              method = "lm",
              formula = y ~ poly(x, 2)) +
  scale_x_continuous(breaks = DOSEN) +
  labs(x = "Dose de N (Kg/ha)",
       y = "Rendimento de grãos (t/ha)")
p1

```



O ponto em X (dose de N) em que a produtividade é máxima é chamado de máxima eficiência técnica (MET) e pode ser estimado por:

$$
MET = \frac{{ - {b _1}}}{{2 \times {b _2}}}
$$

Substituindo com os parâmetros estimados, temos:

$$
MET = \frac{{ - 0,007184}}{{2 \times  -2,071^{-05}}} \approx 173,4
$$


No R, podemos criar uma função auxiliar para calcular o ponto de MET.
```{r}
# máxima eficiência técnica
# mod é o modelo quadrático ajustado
met <- function(mod){
  b1 <- coef(mod)[[2]]
  b2 <- coef(mod)[[3]]
  res <- -b1 / (2 * b2)
  return(res)
}

x_met <- met(mod2)
x_met
```


Em nosso exemplo, o ponto em x (dose de N) que proporciona o máximo rendimento predito é 173,413. Assim para sabermos qual é este rendimento estimado, basta substituir o *x* da equação por 173,4: \$y = 7,075 + 0,007184\times 173,413 -2,071^{-05}\times 173,413^2 \approx 7,70\$

Uma função auxiliar para predição de y em um determinado valor de x considerando um modelo quadrático ajustado é fornecida abaixo.

```{r}
# valor predito para x = MET
# função auxiliar
pred_quad <- function(mod, x){
  b0 <- coef(mod)[[1]]
  b1 <- coef(mod)[[2]]
  b2 <- coef(mod)[[3]]
  pred <- b0 + b1 * x + b2 * x ^ 2
  return(pred)
}
pred_met <- pred_quad(mod2, x = x_met)
pred_met


```


Outro ponto importante que é possível de estimar utilizando uma equação de segundo grau, é a máxima eficiência econômica (MEE), ou seja, a dose máxima, neste caso de nitrogênio, em que é possível aplicar obtendo-se lucro. Este ponto é importante, pois a partir de uma certa dose, os incrementos em produtividade não compensariam o preço pago pelo nitrogênio aplicado. Este ponto pode ser facilmente estimado por:

$$
MEE = MET + \frac{u}{{2 \times b_2 \times m}}
$$

onde *u* e *m* são os preços do nitrogênio e do milho em grão, respectivamente, na mesma unidade utilizada para a estimativa da equação (neste caso, preço do nitrogênio por kg e preço do milho por tonelada). Considerando o preço de custo do nitrogênio como R 3 por kg e o preço de venda do milho a 1,300 por tonelada, substituindo-se na formula obtêm-se:

$$
MEE = 129,56 + \frac{{3,0}}{{2 \times (-2,071^{-05}) \times 1.300}} \approx 100
$$

```{r}
mee <- function(mod, px, py){
  x_met <- met(mod)
  mee <- x_met + px / (2 * coef(mod)[[3]] * py)
  return(mee)
}

x_mee <- mee(mod2, 3, 1300)
x_mee
```

Assim, a dose máxima de nitrogênio que em que os incrementos de produtividade são lucrativos é de \$\approx 117\$ Kg ha\$^{-1}\$, em um rendimento estimado de \$\approx\$ 7,63 Mg ha\$^{-1}\$.

```{r}
# Máxima eficiência econõmica (y)
rg_mee <- pred_quad(mod2, x = x_mee)
rg_mee

```

De posse das informações, um gráfico elaborado, que deveria ser apresentado em todo trabalho deste tipo pode ser confeccionado com a função `plot_lines()` do pacote `metan` combinado com algumas funções do pacote `ggplot2`. Sugiro a leitura do [capítulo 8 deste material](https://tiagoolivoto.github.io/e-bookr/graph.html) para mais informações sobre confecção de gráficos no R.

```{r}
p1 +
  labs(title = "Equação quadrática",
       subtitle = "Trigângulo e cículo representam os pontos de MME e MET, respectivamente",
       caption = "MME = Máxima eficiência econômica\n MET = máxima eficiência técnica") +
  # Linhas e ponto da MET
  geom_segment(aes(x = x_met, y = pred_met, xend = x_met, yend = 6.7)) +
  geom_segment(aes(x = 0, y = pred_met, xend = x_met, yend = pred_met)) +
  geom_point(aes(x = x_met, y = pred_met), shape = 19, size = 3, color = "blue") +
  # Linhas e ponto da MEE
  geom_segment(aes(x = x_mee, y = rg_mee, xend = x_mee, yend = 6.7), linetype = 2) +
  geom_segment(aes(x = 0, y = rg_mee, xend = x_mee, yend = rg_mee), linetype = 2) +
  geom_point(aes(x = x_mee, y = rg_mee), shape = 17, size = 3, color = "blue") +
  # Equação no gráfico
  geom_text(aes(0, 7.9,
                label=(
                  paste(
                    expression("y = 7.075 + 0.007184x - 2,071e"^{-5}*"x"^2*"  R" ^2*" = 0,938 "))
                )
  ),
  hjust = 0,
  size = 5,
  col = "black",
  parse = TRUE) 

```



# Correlação

```{r}
url <- "http://bit.ly/df_biostat_exp"
df_cor <- import(url, sheet = "CORRELACAO_DATA", setclass = "tbl")

# correlação de pearson (AP e A)
cor(df_cor)


# matriz de correlação
df_mat <- import(url, sheet = "maize", setclass = "tbl")
df_maize <- 
  df_mat %>% 
  select(APLA:MGRA)
cor(df_maize)

# Matriz gráfica de correlação
corr_plot(df_maize)
```


# Notas da aula prática
Os dados utilizados referem-se a uma amostra de tamanho n = 11, na qual se aplicou CO2 em diferentes concentrações em folhas de trigo (X). A quantidade de C02 absorvida (Y) em cm3 / dm2 / hora foi avaliada.

## Regressão
### Dados
> Neste exemplo, será utilizado Os dados referente a uma amostra de tamanho n = 11, na qual se aplicou CO2 em diferentes concentrações em folhas de trigo (X). A quantidade de C02 absorvida (Y) em cm3 / dm2 / hora foi avaliada. Esse exemplo foi apresentado por Ferreira (2009)[^1]


```{r}
url <- "http://bit.ly/df_biostat_exp"
df_co2 <- import(url, sheet = "REG_PRATICA", setclass = "tbl")

(x <- df_co2$x)
(y <- df_co2$y)
(n <- length(x))
(mx <- mean(x))
(my <- mean(y))
```


### Método dos mínimos quadrados
```{r}
(xy <- x * y)
(x2 <- x ^ 2)
(y2 <- y ^ 2)

(sxy <- sum(xy) - (sum(x) * sum(y) / n))
(sx <- sum(x2) - sum(x) ^ 2 / n)
(sy <- sum(y2) - sum(y) ^ 2 / n)

(b1 <- sxy / sx)
(b0 <- my - b1 * mx)

## somas de quadrados
(sqtotal <- sy)
(sqreg <- sxy ^ 2 / sx)
(sqres <- sqtotal - sqreg)
(R2 <- sqreg / sqtotal)
```

### Função `lm`

Utilizando a função `lm`, o modelo acima é ajustado facilmente, com:
```{r}
mod <- lm(y ~ x)
summary(mod)
```

### Valores preditos
Para obter os valores preditos, precisamos considerar os parâmetros estimados da regressão linear, substituindo o *x* pelos valores observados de x. Felizmente, a vetorização proporcionada pelo R, nos facilita este procedimento, bastando realizar o seguinte comando

```{r}
(pred <- b0 + b1 * x)
```

Os valores preditos também podem ser obtidos com a função `predict()`, informando o modelo ajustado

```{r}
(pred2 <- predict(mod))
```

### Residuais
Os resíduos são obtidos pela diferença entre os valores observados e os preditos pelo modelo ajustado. Para isso, utilizamos o seguinte comando:
```{r}
(res <- y - pred)

```

Apenas para fins de comprovação, observe que a soma de quadrado do resíduo obtida anteriormente pode ser calculada agora como:
```{r}
(sqres2 <- sum(res ^ 2))
```

A função `residuals()` também pode ser utilizada para oter os resíduos de um modelo ajustado.
```{r}
(res2 <- residuals(mod))
```

### Gráfico
Para confecção do gráfico de regressão, será utilizado o pacote `ggplot2`

```{r}
# gráfico base
ggplot(df_co2, aes(x, y)) +
  geom_point(size = 4, color = "red") +
  labs(x = "CO2 aplicado",
       y = "CO2 absorvido") +
  geom_segment(aes(x = x, y = y, xend = x, yend = fitted(mod))) +
  geom_smooth(se = FALSE, method = "lm")
```


## Correlação
### Dados
> Dois métodos de mensurar a densidade média da madeira (g /cm\$^3\$) em *Eucalyptus grandis* foram aplicados a uma amostra de n = 13 árvores. O primeiro método (X) é determinado utilizando um paquímetro e uma sonda Pressler de 0,5 cm na região da árvore determinada no diâmetro à altura do peito (DAP). A segunda, variável (Y) também foi mensurada no DAP utilizando cortes transversais no tronco. Esse exemplo foi apresentado por Ferreira (2009)[^1]

```{r}
url <- "http://bit.ly/df_biostat_exp"
df_densidade <- import(url, sheet = "COR_DATA_DENSIDADE", setclass = "tbl")

x <- df_densidade$X
y <- df_densidade$Y
n <- length(x)

```

### método dos mínimos quadrados
```{r}
xy <- x * y
x2 <- x ^ 2
y2 <- y ^ 2

(sxy <- sum(xy) - (sum(x) * sum(y) / n))
(sx <- sum(x2) - sum(x) ^ 2 / n)
(sy <- sum(y2) - sum(y) ^ 2 / n)

(r <- sxy / sqrt(sx * sy))

(tcal <- r * (sqrt((n - 2) / (1 - r ^ 2))))
(ttab <- abs(qt(0.025, df = 11)))
tcal > ttab

```

### Função `cor()`

Para computar o coeficiente de correlação de Pearson, utilizamos a função `cor()`, indicando o vetor x e y, ou um data.frame com variáveis numéricas. Neste último caso, uma matriz de correlação é retornada.
```{r}
cor(x, y)
```

Para realizar o teste de hipótese, utiliza-se a função `cor.test()`.

```{r}
cor.test(x, y)
```


# Exercício resolvido
## Correlação
### Dados
> Neste exemplo, serão utilizados dados referentes ao número de grãos (NGRA) e massa de grãos (MGRA) observados em 15 espigas de milho (n = 15).


```{r}
url <- "http://bit.ly/df_biostat_exp"
cor_ex <- import(url, sheet = "COR_EXERCICIO", setclass = "tbl")

(x <- cor_ex$NGRA)
(y <- cor_ex$MGRA)
(n <- length(x))
```


### Método dos mínimos quadrados
```{r}
(xy <- x * y)
(x2 <- x ^ 2)
(y2 <- y ^ 2)

# soma de xy
(somxy <- sum(xy))

# soma de x
(somx <- sum(x))

# soma de y
(somy <- sum(y))

# soma de x2
(somx2 <- sum(x2))

# soma de y2
(somy2 <- sum(y2))

# adiciona as colunas nos dados originais usando mutate()
cor_ex <- 
  mutate(cor_ex,
         xy = xy,
         x2 = x2,
         y2 = y2)
data.frame(cor_ex)


# soma de produtos xy
(sxy <- somxy - (somx * somy / n))

# soma de quadrados de x
(sx <- somx2 - somx ^ 2 / n)

# soma de quadrados de y
(sy <- somy2 - somy ^ 2 / n)

# coeficiente de correlaçao
(r <- sxy / (sqrt(sx * sy)))


# t calculado
(tc <- r * sqrt((n - 2) / (1 - r ^ 2)))

# t tabelado (cauda direita) = 2.16
# como é bicaudal, considera-se 0.05 / 2
qt(0.025, df = 13, lower.tail = FALSE)


```

### Função cor e cor.test()
```{r}
# somente calcula o r
cor(x, y)


# computa o r e realiza o teste de hipótese
cor.test(x, y)
```


## Regressão
### Dados
> Neste exemplo, serão utilizados dados de produtividade de grãos de milho (Kg /ha) de acordo com diferentes doses de dejeto suíno (m3/ha) aplicadas na cultura do milho[^2].


```{r}
url <- "http://bit.ly/df_biostat_exp"
reg_ex <- import(url, sheet = "REG_EXERCICIO", setclass = "tbl")

(x <- reg_ex$DOSE)
(y <- reg_ex$RG)
# número de amostras
(n <- length(x))
# médias 
(mx <- mean(x))
(my <- mean(y))
```


### Método dos mínimos quadrados
```{r}
# x vezes y
(xy <- x * y)

# x ao quadrado
(x2 <- x ^ 2)

# y ao quadrado
(y2 <- y ^ 2)

# soma de xy
(somxy <- sum(xy))

# soma de x
(somx <- sum(x))

# soma de y
(somy <- sum(y))

# soma de x2
(somx2 <- sum(x2))

# soma de y2
(somy2 <- sum(y2))

# soma de produtos xy
(sxy <- somxy - (somx * somy / n))

# soma de quadrados de x
(sx <- somx2 - somx ^ 2 / n)

# soma de quadrados de y
(sy <- somy2 - somy ^ 2 / n)

# b1
(b1 <- sxy / sx)

# b0
(b0 <- my - mx * b1)

# equação: y = 6150 + 46,2x

# y predito com x = 35
(yx35 <- b0 + b1 * 35)


################## SOMAS DE QUADRADOS DA REGRESSÃO E R2 ############
# soma de quadrado total
(sqt <- sy)

# soma de quadrados da regressão
(sqreg <- sxy ^ 2 / (sx))

# soma de quadrados do resíduo
(sqres <- sqt - sqreg)

# coeficiente de determinação
R2 <- sqreg / sqt
```

### Utilizando a função lm()

```{r}
reg <- lm(y ~ x)

# coeficientes e R2
summary(reg)

# anova
anova(reg)

```


### Gráfico
```{r}
library(ggpmisc) # adiciona a equação no gráfico
ggplot(reg_ex, aes(DOSE, RG)) +
  geom_smooth(se = FALSE, method = "lm") +
  geom_segment(aes(x = 35, y = 7000, xend = 35, yend = yx35)) +
  geom_segment(aes(x = 18, y = yx35, xend = 35, yend = yx35)) +
  geom_point(aes(x = 35, y = yx35), color = "red", size = 4) +
  geom_point(size = 4, color = "blue") + 
  stat_poly_eq(formula = y ~ x,
               aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")),
               coef.digits = 5) +
  labs(x = "Dose de dejeto (m3/ha)",
       y = "Rendimento de grãos (kg/ha)")
```


[^1]: FERREIRA, D. F. **Estatistica Basica**. 2. ed. Viçosa, MG.: UFV, 2009
[^2]: https://periodicos.uem.br/ojs/index.php/ActaSciTechnol/article/download/5312/5312/
