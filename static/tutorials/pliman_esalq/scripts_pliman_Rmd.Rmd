---
title: Scripts R - pliman 
---
##Aufgabe 1

```{r global_options, include = FALSE}
knitr::opts_knit$set(root.dir = "E:/Desktop/tiagoolivoto/static/tutorials/pliman_esalq/leaves")
```

# Diretório das imagens
```{r eval=FALSE}
# mudar de acordo com a pasta em seu computador
setwd("E:/Desktop/tiagoolivoto/static/tutorials/pliman_esalq/leaves")
```


# Importar imagens
```{r collapse = TRUE, message=FALSE, warning=FALSE}

library(pliman)  
img <- image_import("img_1.jpeg")
plot(img)

```



Para importar uma lista de imagens, o argumento `pattern` da função `image_import()` é usado. Todas as imagens que correspondem ao nome do padrão são importadas para uma lista.

```{r import2}

img_list <-
  image_import(pattern = "img_")
names(img_list)
```



# Exibindo imagens
Imagens individuais são exibidas com `plot()`. Para combinar imagens, a função `image_combine()` é usada. Os usuários podem informar uma lista de objetos separados por vírgulas ou uma lista de objetos da classe `Image`.

```{r display1, fig.width = 12}
# Imagens individuais
plot(img)

```



```{r display2, fig.width = 12}

# Combine imagens
image_combine(img_list)


```


# Manipulando imagens


`pliman` fornece um conjunto de funções `image_*()` para realizar a manipulação de imagens e transformação de imagens exclusivas ou uma lista de imagens baseada no [pacote EBImage](https://www.bioconductor.org/packages/release/bioc/vignettes/EBImage/inst/doc/EBImage-Introduction.html).

## Redimensionar uma imagem
Às vezes, o redimensionamento de imagens de alta resolução é necessário para reduzir o esforço computacional e tempo de processamento. A função `image_resize()` é usada para redimensionar uma imagem. O argumento `rel_size` pode ser usado para redimensionar a imagem por tamanho relativo. Por exemplo, definindo `rel_size = 50` para uma imagem de largura 1280 x 720, a nova imagem terá um tamanho de 640 x 360.

```{r manipulate1}
image_dimension(img)
img_resized <- image_resize(img, rel_size = 50)
image_dimension(img_resized)
```


## Cortar uma imagem
Cortar imagens é útil para remover ruídos da borda da imagem, bem como para reduzir o tamanho das imagens antes do processamento. Para recortar uma imagem, a função `image_crop()` é usada. Os usuários precisam informar um vetor numérico indicando a faixa de pixels (`width` e `height`) que será mantida na imagem recortada.

```{r}
crop1 <-
  image_crop(img,
             width = 38:1530,
             height = 168:874,
             plot = TRUE)
```

Se apenas `width` ou `height` forem informados, a imagem será recortada verticalmente ou horizontalmente.

```{r}
crop2 <-
  image_crop(img,
             width = 38:1530,
             plot = TRUE)
```

Se `width` e `height` não forem declarados, um processo iterativo de corte da imagem é executado.

```{r eval = FALSE}
# executa apenas em uma seção iterativa
image_crop(img)
```


Além disso, um processo de corte automatizado pode ser executado. Nesse caso, a imagem será cortada automaticamente na área de objetos com uma borda de cinco pixels por padrão.

```{r}
auto_crop <- image_autocrop(img, plot = TRUE)
```


A função `image_trim()` é usada para cortar pixels das bordas da imagem.


```{r manipulate2, fig.width = 10}
# apara 100 pixels de todas as bordas
img_trim <- image_trim(img, edge = 100, plot = TRUE)

# O mesmo é alcançado com
img_trim2 <-
  image_trim(img,
             top = 100,
             bottom = 100,
             left = 100,
             right = 100,
             plot = TRUE)

# apara 200 pixels da parte superior e inferior
img_trim3 <-
  image_trim(img,
             top = 200,
             bottom = 200,
             plot = TRUE)


```




## Resolução da imagem(DPI) {#dpi}
A função `dpi()` executa uma função interativa para calcular a resolução da imagem dada uma distância conhecida informada pelo usuário. Para calcular a resolução da imagem(dpi), o usuário deve usar o botão esquerdo do mouse para criar uma linha de distância conhecida. Isso pode ser feito, por exemplo, usando um modelo com distância conhecida na imagem(por exemplo, `leaves.JPG`).

```{r eval = FALSE}
# executado apenas em uma seção interativa
rule <- image_import("rule.jpg", plot = TRUE)
dpi(rule)
```





## Filtro, desfoque, contraste, dilatação e erosão

```{r manipulate6, fig.width = 10, fig.height = 6}
img_filter <- image_filter(img)
img_blur <- image_blur(img)
img_contrast <- image_contrast(img)
img_dilatation <- image_dilate(img)
img_erosion <- image_erode(img)
image_combine(img, img_filter, img_blur, img_contrast, img_dilatation, img_erosion)
```



## Exportando imagens
Para exportar imagens para o diretório atual, use a função `image_export()`. Se uma lista de imagens for exportada, as imagens serão salvas considerando o nome e a extensão presentes na lista. Se nenhuma extensão estiver presente, as imagens serão salvas como arquivos `* .jpg`.

```{r export, eval=FALSE}
imagem_exportar(img, "img_exported.jpg")
```



```{r, echo=FALSE, eval=TRUE}
```
##Aufgabe 2

# Diretório das imagens
```{r eval=FALSE}
# mudar de acordo com a pasta em seu computador
setwd("E:/Desktop/tiagoolivoto/static/tutorials/pliman_esalq/leaves")
```


# Importar imagens
```{r collapse = TRUE, message=FALSE, warning=FALSE}
library(pliman)  
img <- image_import("img_1.jpeg")
img <- image_resize(img, 50)
plot(img)

```


# Segmentação de imagem

No `pliman`, as seguintes funções podem ser usadas para segmentar uma imagem.

* `image_binary()` para produzir uma imagem binária(preto e branco)
* `image_segment()` para produzir uma imagem segmentada(objetos de imagem e um fundo branco).
* `image_segment_iter()` para segmentar uma imagem iterativamente.

Ambas as funções segmentam a imagem com base no valor de algum índice de imagem, que pode ser uma das bandas RGB ou qualquer operação com essas bandas. Internamente, essas funções chamam `image_index()` para calcular esses índices.

Aqui, usamos o argumento `index" `para testar a segmentação com base no RGB e seus valores normalizados. Os usuários também podem fornecer seu índice com o argumento` my_index`.

```{r segmentação2, fig.width = 10, fig.height = 5}
# Calcule os índices
indexes <- image_index(img, index = c("R, G, B, NR, NG, NB"))

# Crie um gráfico raster com os valores RGB
plot(indexes)

# Crie um histograma com os valores RGB
plot(indexes, type = "hist")
```

Neste exemplo, podemos ver a distribuição dos valores RGB (primeira linha) e os valores RGB normalizados (segunda linha). Os dois picos representam a folha (pico menor) e o fundo (pico maior). Quanto mais clara for a diferença entre esses picos, melhor será a segmentação da imagem.

A função `image_segmentation()` é usada para segmentar imagens usando índices de imagem. Em nosso exemplo, usaremos os mesmos índices calculados abaixo para ver como a imagem é segmentada. A saída desta função pode ser usada como entrada na função `analyze_objects()`.

```{r segmentação3, fig.width = 10, fig.height = 5}
segmented <- image_segment(img, index = c("R, G, B, NR, NG, NB"))

```

Parece que o índice `"G"` proporcionou melhor segmentação. 



# Produzindo uma imagem binária

Também podemos produzir uma imagem binária com `image_binary()`. A título de curiosidade, usaremos os índices `"B"` (azul). Por padrão, `image_binary()` redimensiona a imagem para 30% do tamanho da imagem original para acelerar o tempo de computação. Use o argumento `resize = FALSE` para produzir uma imagem binária com o tamanho original.

```{r binary1, fig.width = 10, fig.height = 5}
binary <- image_binary(img)

# tamanho de imagem original
image_binary(img,
             index = "G",
             resize = FALSE)
```

Para contornar a questão de pixeis não segmentados no interior da image, o argumento `fill_hull` pode ser utilizado.


```{r binary2, fig.width = 10, fig.height = 5}

image_binary(img,
             index = "G",
             resize = FALSE,
             fill_hull = TRUE)
```
```{r, echo=FALSE, eval=TRUE}
```
##Aufgabe 3

# Diretório das imagens
```{r eval=FALSE}
# mudar de acordo com a pasta em seu computador
setwd("E:/Desktop/tiagoolivoto/static/tutorials/pliman_esalq/leaves")
```


# Severidade da doença
## Utilizando paletas

```{r doença1, fig.width = 12, fig.height = 3}
# gerar tabelas html
print_tbl <- function(table,  digits = 3, ...){
  knitr::kable(table, booktabs = TRUE, digits = digits, ...)
}
library(pliman)
img <- image_import("img_1.jpeg")
h <- image_import("h_img1.png")
d <- image_import("d_img1.png")
b <- image_import("b_img1.png")
image_combine(img, h, d, b, ncol = 4)
```


### Padrão da função
```{r}
sev <- 
  measure_disease(img = img,
                  img_healthy = h,
                  img_symptoms = d,
                  img_background = b,
                  show_image = TRUE)
```


### Mostrando preenchimento das lesões
```{r}
sev <- 
  measure_disease(img = img,
                  img_healthy = h,
                  img_symptoms = d,
                  img_background = b,
                  show_image = TRUE,
                  show_contour = FALSE)
```


### Mostrando uma máscara
```{r}
sev <- 
  measure_disease(img = img,
                  img_healthy = h,
                  img_symptoms = d,
                  img_background = b,
                  show_image = TRUE,
                  show_contour = FALSE,
                  show_original = FALSE)
```


### Segmentando as lesões
```{r}
sev <- 
  measure_disease(img = img,
                  img_healthy = h,
                  img_symptoms = d,
                  img_background = b,
                  show_image = TRUE,
                  show_contour = FALSE,
                  segment = TRUE,
                  show_segmentation = TRUE)
```


### Analisar as lesões
```{r}
feat <- 
  measure_disease(img = img,
                  img_healthy = h,
                  img_symptoms = d,
                  img_background = b,
                  show_image = TRUE,
                  show_contour = FALSE,
                  segment = TRUE,
                  show_segmentation = TRUE,
                  show_features = TRUE)


print_tbl(feat$statistics)
print_tbl(feat$shape[1:10, ])

# corrigir as medidas (dpi = 100)
feat_corrected <- get_measures(feat, dpi = 150)
```


### A little bit more!
```{r}
# library(pliman)
sev_img2 <- 
  measure_disease(img = "img_2",
                  img_healthy = "h_img2",
                  img_symptoms = "d_img2",
                  img_background = "b_img2",
                  show_image = FALSE,
                  show_contour = FALSE,
                  col_background  = "black")


imgs <- image_import(c("img_2.jpeg", "mask_im2.jpeg"))
image_combine(imgs)
```



## Utilizando índices RGB
Para identificar o melhor índice para segmentar a imagem do fundo e após as lesões da folha sadia, pode-se utilizar a função `image_segment_iter`. (OBS. somente funcionará em uma seção iterativa).


```{r eval=FALSE}
image_segment_iter(img)

```

Após escolhidos os índices, podemos utilizar os argumentos `index_lb` e `index_dh` para segmentação da folha e fundo | lesão e sadio, respectivamente.

```{r}
# após escolhidos os índices, utiliza
sev_index <- 
  measure_disease(img, 
                  index_lb = "G",
                  index_dh = "NGRDI",
                  show_image = TRUE)
```


## Processamento em lote
Para analisar diversas imagens de um diretório, utiliza-se o argumento `pattern`, para declarar um padrão de nomes de arquivos. Serão utilizadas 15 folhas de soja disponíveis no repositório  https://osf.io/4hbr6, um banco de dados de imagens de anotação de severidade de doenças de plantas. Obrigado a [Emerson M. Del Ponte](https://osf.io/jb6yd/) e seus colaboradores por manter este projeto disponível publicamente.

```{r}

system.time(
  sev_lote <- 
    measure_disease(pattern = "soy",
                    img_healthy = "h_s",
                    img_symptoms = "d_s",
                    img_background = "b_s",
                    verbose = FALSE)
)
print_tbl(sev_lote)
```



Para acelerar o tempo de processamento quando várias imagens estão disponíveis, pode-se utilizar o argumento `paralell`. Isto criará múltiplas seções R em segundo plano, sendo cada uma responsável pelo processamento de uma parte das imagens.

```{r}
system.time(
  sev_lote <- 
    measure_disease(pattern = "soy",
                    img_healthy = "h_s",
                    img_symptoms = "d_s",
                    img_background = "b_s",
                    verbose = FALSE,
                    parallel = TRUE)
)
```



## Desafios

### Lesões com pouco contraste


```{r}
pepper <- image_import("pepper.png", plot = TRUE)
image_index(pepper, index = "all")
```

### Fundos complexos
```{r}

img <- image_import("maize_1.png", plot = TRUE)
image_segment(img, index = "all")



img <- image_import("maize_2.png", plot = TRUE)
image_segment(img, index = "all")




img2 <- image_crop(img,
                   width = 959:32,
                   height = 163:557,
                   plot = TRUE)



image_segment_iter(img2, 
                   nseg = 2,
                   index = c("R/(G+B)", "GLI"),
                   invert = c(T, F),
                   ncol = 3)


img <- image_import("maize_3.png", plot = TRUE)
image_segment(img, index = "all")

```

```{r, echo=FALSE, eval=TRUE}
```
