% Análise 

```{r global_options, include = FALSE}
knitr::opts_chunk$set(cache = FALSE, comment = "#", collapse = TRUE)

```



# Manipulação e segmentação
## Diretório das imagens
```{r eval=FALSE}
# mudar de acordo com a pasta em seu computador
setwd("E:/Desktop/UFSC/cursos/pliman_imgp/imgs")
```

```{r echo = FALSE}
knitr::opts_knit$set(root.dir = "E:/Desktop/UFSC/cursos/pliman_imgp/imgs")
```


## Importar imagens
```{r collapse = TRUE, message=FALSE, warning=FALSE}
library(pliman)
library(tidyverse)
library(patchwork)
img <- image_import("soy1.jpeg")

```



Para importar uma lista de imagens, use um vetor de nomes de imagens, ou o argumento `pattern`. Neste último, todas as imagens que correspondem ao nome do padrão são importadas para uma lista.

```{r import2}
img_list1 <- image_import(c("img_sb_50_1.jpg", "img_sb_50_2.jpg"))
img_list2 <- image_import(pattern = "img_sb_")
str(img_list2)
```


## Exibindo imagens
Imagens individuais são exibidas com `plot()`. Para combinar imagens, a função `image_combine()` é usada. Os usuários podem informar uma lista de objetos separados por vírgulas ou uma lista de objetos da classe `Image`.

```{r display1, fig.width = 10, fig.height=6}
# Imagens individuais
plot(img)

```



```{r display2, fig.width = 10, fig.height=5}
# Combine imagens
image_combine(img_list1)
```




`pliman` fornece um conjunto de funções `image_*()` para realizar a manipulação de imagens e transformação de imagens exclusivas ou uma lista de imagens baseada no [pacote EBImage](https://www.bioconductor.org/packages/release/bioc/vignettes/EBImage/inst/doc/EBImage-Introduction.html).

## Redimensionar uma imagem
Às vezes, o redimensionamento de imagens de alta resolução é necessário para reduzir o esforço computacional e tempo de processamento. A função `image_resize()` é usada para redimensionar uma imagem. O argumento `rel_size` pode ser usado para redimensionar a imagem por tamanho relativo. Por exemplo, definindo `rel_size = 50` para uma imagem de largura 1280 x 720, a nova imagem terá um tamanho de 640 x 360.

```{r manipulate1}
image_dimension(img)
img_resized <- image_resize(img, rel_size = 50)
image_dimension(img_resized)
```





## Resolução da imagem (DPI) {#dpi}
A função `dpi()` executa uma função interativa para calcular a resolução da imagem dada uma distância conhecida informada pelo usuário. Para calcular a resolução da imagem (dpi), o usuário deve usar o botão esquerdo do mouse para criar uma linha de distância conhecida. Isso pode ser feito, por exemplo, usando um modelo com distância conhecida, como à seguir.

```{r eval = FALSE}
# executado apenas em uma seção interativa
rule <- image_import("rule.jpg", plot = TRUE)
dpi(rule)
```




## Exportando imagens
Para exportar imagens para o diretório atual, use a função `image_export()`. Se uma lista de imagens for exportada, as imagens serão salvas considerando o nome e a extensão presentes na lista. Se nenhuma extensão estiver presente, as imagens serão salvas como arquivos `*.jpg`.

```{r export, eval=FALSE}
image_export(img, "img_exported.jpg")

# exportar lista (exemplo de subpasta)
image_export(img_list2,
             subfolder = "lista_exportada")
```




## Segmentação

No `pliman`, as seguintes funções podem ser usadas para segmentar uma imagem.

* `image_binary()` para produzir uma imagem binária (preto e branco)
* `image_segment()` para produzir uma imagem segmentada (objetos de imagem e um fundo branco).
* `image_segment_iter()` para segmentar uma imagem iterativamente.

Ambas as funções segmentam a imagem com base no valor de algum índice de imagem, que pode ser uma das bandas RGB ou qualquer operação com essas bandas. Internamente, essas funções chamam `image_index()` para calcular esses índices. Aqui, usamos o argumento `index" `para testar a segmentação com base no RGB e seus valores normalizados. Os usuários também podem fornecer seu índice com o argumento` my_index`.

```{r segmentação2, fig.width = 10, fig.height = 5}
img <- 
  image_import("leaf5.jpg", plot = TRUE) %>% 
  image_resize(30) # reduz a resolução (plota mais rápido)

# Calcule os índices
indexes <- image_index(img, index = c("R, G, B"))

# Crie um gráfico raster com os valores RGB
plot(indexes, ncol = 3)

# Cria um histograma com os valores RGB
plot(indexes,
     type = "density",
     ncol = 3)
```

Os dois picos representam a folha (pico menor) e o fundo (pico maior). Quanto mais clara for a diferença entre esses picos, melhor será a segmentação da imagem.

A função `image_segment()` é usada para segmentar imagens usando índices de imagem. Em nosso exemplo, usaremos os mesmos índices calculados abaixo para ver como a imagem é segmentada. A saída desta função pode ser usada como entrada na função `analyze_objects()`.

```{r segmentação3, fig.width = 10, fig.height = 5}
segmented <- image_segment(img, index = "B")
```




## Produzindo uma imagem binária

No pliman, podemos produzir uma imagem binária com `image_binary()`. A título de curiosidade, usaremos os índices `"B"` (azul). Por padrão, `image_binary()` redimensiona a imagem para 30% do tamanho da imagem original para acelerar o tempo de computação. Use o argumento `resize = FALSE` para produzir uma imagem binária com o tamanho original.

```{r binary1, fig.width = 10, fig.height = 5}
binary <- image_binary(img, index = "B")

# tamanho de imagem original
image_binary(img,
             index = "B",
             resize = FALSE)

# inverte a binarização
image_binary(img,
             index = "B",
             resize = FALSE,
             invert = TRUE)
```



# Contagem de objetos
## Imagem por imagem

Aqui, contaremos os grãos na imagem `soy1.jpeg`. Esta imagem tem um fundo branco e contém 42 grãos de soja. A função `analyze_objects()` segmenta a imagem usando como padrão o índice azul normalizado, como segue $NB =(B /(R + G + B))$, onde *R*, *G* e *B* são as faixas vermelha, verde e azul. Os objetos são contados e os objetos segmentados são coloridos com permutações aleatórias.



```{r, fig.width = 12, fig.height = 6}
soy <- image_import("soy1.jpeg", plot = TRUE)

# contagem manual
# pick_count(soy)

# contagem automática
count <- analyze_objects(soy)
count$statistics
```



Os usuários podem definir `show_contour = FALSE` para remover a linha de contorno e identificar os objetos (neste exemplo, os grãos) usando os argumentos `marker = "id"`. A cor do fundo também pode ser alterada com `col_background`.



```{r, fig.width = 12, fig.height = 6}
count2 <-
  analyze_objects(soy,
                  watershed = FALSE,
                  show_contour = FALSE,
                  marker = "id",
                  show_original = FALSE,
                  show_segmentation = TRUE) # padrão

```



## Processamento em lote

Na análise de imagens, frequentemente é necessário processar mais de uma imagem. Por exemplo, no melhoramento de plantas, o número de grãos por planta (por exemplo, trigo) é frequentemente usado na seleção indireta de plantas de alto rendimento. No `pliman`, o processamento em lote pode ser feito quando o usuário declara o argumento `pattern`.


Para acelerar o tempo de processamento, especialmente para um grande número de imagens, o argumento `parallel = TRUE` pode ser usado. Nesse caso, as imagens são processadas de forma assíncrona (em paralelo) em sessões `R` separadas rodando em segundo plano na mesma máquina. O número de seções é configurado para 50% dos núcleos disponíveis. Este número pode ser controlado explicitamente com o argumento `workers`.


```{r}
system.time(
  list_res <- analyze_objects(pattern = "img_sb", show_image = FALSE)
)

# procesamento paralelo
# três múltiplas seções (observe o tempo!)
system.time(
  list_res <- 
    analyze_objects(pattern = "img_sb",
                    show_image = FALSE,
                    parallel = TRUE,
                    workers = 3)
)

```





# Características de objetos

A função `analyze_objects()` pode ser usada para obter características de objetos de uma imagem. Vamos começar com um exemplo simples com a imagem `object_300dpi.png`. Esta imagem é distribuída com a instalação do pacote e pode ser obtida com `image_pliman()`.


```{r collapse=TRUE}
img <- image_pliman("objects_300dpi.jpg", plot = TRUE)

```


A imagem acima foi produzida com o Microsoft PowerPoint. Tem uma resolução conhecida de 300 dpi(pontos por polegada) e mostra quatro objetos

- Quadrado maior: 10 x 10 cm (100 cm$^2$)  
- Quadrado menor: 5 x 5 cm(25 cm$^2$)  
- Retângulo: 4 x 2 cm(8 cm$^2$)  
- Círculo: 3 cm de diâmetro(~7,07 cm$^2$)  

Para contar os objetos na imagem usamos `analyze_objects()` e informamos a imagem (o único argumento obrigatório).

```{r, fig.width = 10, fig.height = 5}
img_res <- analyze_objects(img, marker = "id")

```


## Ajustando as medidas do objeto

Os resultados foram armazenados em `img_res`. Como não há escala declarada no exemplo acima, não temos ideia sobre a área real dos objetos em cm$^2$, apenas em pixels. Neste caso, usamos `get_measures()` para ajustar as medidas de pixels para unidades métricas.

Existem duas formas principais de ajustar as medidas do objeto (de pixels a cm, por exemplo). O primeiro é declarar a área, perímetro ou raio conhecido de um determinado objeto. A medida para os outros objetos será então calculada por uma regra de três simples. A segunda é declarando uma resolução de imagem conhecida em dpi (pontos por polegada). Neste caso, perímetro, área e raio serão ajustados pelo dpi informado.


### Declarando um valor conhecido

Como conhecemos a área do quadrado maior (objeto 1), vamos ajustar a área dos outros objetos na imagem usando isso.


```{r}
get_measures(img_res,
             id = 1,
             area ~ 100)

```



### Declarando a resolução da imagem

Se a resolução da imagem for conhecida, todas as medidas serão ajustadas de acordo com esta resolução. Abaixo, os valores de todas as medidas são ajustados declarando o argumento `dpi` em` get_measures()`.

```{r}
img_res_cor <- get_measures(img_res, dpi = 300) |> as.data.frame()
img_res_cor
```


## Entendendo as medidas

```{r}
object_contour(img) %>%  # obtém o contorno dos objetos
  poly_mass() %>%        # computa o centro de massa e raios mínimo e máximo
  plot_mass()            # plota as medidas
```

* Quadrado maior:
- O diâmetro mínimo (a = 9,97) pode ser considerado como o lado do quadrado

- O diâmetro máximo, dado por $a \sqrt{2}$ pode ser considerado a diagonal do quadrado ($9,97 \sqrt{2} = 14.099$ 

Neste outro exemplo, usarei a imagem `potato_leaves.png`, que foi coletada de [Gupta et al.(2020)](https://doi.org/10.1111/nph.16286)


```{r batata, fig.width = 10}
batata <- image_pliman("potato_leaves.jpg", plot = TRUE)

pot_meas <-
  analyze_objects(batata,
                  watershed = FALSE,
                  marker = "id",
                  show_chull = TRUE) # mostra o casco convex
pot_meas$results

```


As três medidas principais (em unidades de pixel) são:

1. `area` a área do objeto.
2. `area_ch` a área do casco convexo.
3. `perímetro` o perímetro do objeto.

Usando essas medidas, a circularidade e a solidez são calculadas conforme mostrado em (Gupta et al, 2020).

$$
circularidade = 4 \pi(area / perimeter ^ 2)
$$





$$
solidez = area / area \_ch
$$



A circularidade é influenciada por serrilhas e saliências. A solidez é sensível a folhas com lóbulos profundos ou com pecíolo distinto e pode ser usada para distinguir folhas sem tais estruturas. Ao contrário da circularidade, não é muito sensível a serrilhas e saliências menores, uma vez que o casco convexo permanece praticamente inalterado.



## Comprimento e largura
No exemplo a seguir, mostro como calcular o contorno do objeto, o centro de massa e os raios máximo e mínimo (em unidades de pixel). Nesse caso, o diâmetro mínimo e máximo (calculado com `analyze_objects()`) pode ser usado como uma medida para aproximar a largura e o comprimento do grão do feijão, respectivamente.


```{r}
bean <- image_import("bean.jpg", plot = TRUE)

bean_meas <- 
  analyze_objects(bean,
                  index = "G",
                  fill_hull = TRUE,
                  watershed = FALSE,
                  show_contour = FALSE,
                  col_background = "black",
                  marker = "id",
                  threshold = 0.45)
bean_meas_cor <- get_measures(bean_meas, dpi = 300)
bean_meas_cor[, c("id", "diam_min", "diam_max")]


# contorno
cont <- 
  object_contour(bean,
                 index = "G",
                 watershed = FALSE,
                 show_image = FALSE)

plot_contour(cont, col = "white", lwd = 2)

# centro de massa
cm <- poly_mass(cont)
plot_mass(cm,
          col = "white",
          arrow = TRUE)

# plota a largura e comprimento
plot_measures(bean_meas_cor, measure = "diam_min", vjust = 120)
plot_measures(bean_meas_cor, measure = "diam_max", hjust = 180)
```




## Área foliar
### Uma imagem
```{r}
folhas <- image_import(image = "leaves.jpg", plot = TRUE)
af <-
  analyze_objects(folhas,
                  marker = "id",
                  watershed = FALSE,
                  show_contour = FALSE,
                  col_background = "black")

af_cor <- get_measures(af, dpi = 50.5)
plot_measures(af_cor,
              vjust = -25,
              col = "red",
              measure = "area")

get_measures(af, id = 30, area ~ 25)
```


### Preenchendo 'buracos'
Um aspecto importante a se considerar é quando há a presença de 'buracos' nas folhas. Isto pode ocorrer, por exemplo, pelo ataque de pragas. Neste caso, a área teria que ser considerada, pois ela estava lá!

```{r fig.width=10, fig.height=6}
holes <- image_import("holes.jpg", plot = TRUE)

af <-
  analyze_objects(holes,
                  watershed = FALSE,
                  col_background = "white",
                  marker = "area",
                  marker_col = "red",
                  marker_size = 3,
                  show_image = FALSE,
                  save_image = TRUE,
                  dir_processed = tempdir(),
                  contour_size = 5)

af2 <-
  analyze_objects(holes,
                  fill_hull = TRUE, # preenche 'buracos'
                  watershed = FALSE,
                  col_background = "white",
                  marker = "area",
                  marker_col = "red",
                  marker_size = 3,
                  show_image = FALSE,
                  save_image = TRUE,
                  prefix = "proc2_",
                  dir_processed = tempdir(),
                  contour_size = 5)

imgs <- image_import(pattern = "proc", path = tempdir())
image_combine(imgs)
```


### Usando um objeto de referência (dev version)

Na versão de desenvolvimento, foi incluído o argumento `reference`. Isto possibilita corrigir as medidas de objetos utilizando um objeto de referência. Neste exemplo, a área foliar da imagem `img_ref` é quantificada e corrigida considerando como objeto de referência, um retângulo de 2 x 6 (12 cm$^2$). Para isso, é necessário fornecer paletas de cores referentes ao fundo (`background`), folhas (`foreground`) e o objeto de referência (`reference`). Além disso, a área do objeto de referência precisa ser informada em `reference_area`.

```{r}
img <- image_import(pattern = "ref_", plot = TRUE)

area <- 
  analyze_objects(img = "ref_img",
                  foreground = "ref_leaf",
                  background = "ref_back",
                  reference = "ref_ref",
                  reference_area = 12,
                  marker = "area",
                  watershed = FALSE)
```



### Várias imagens da mesma amostra

Se os usuários precisarem analisar várias imagens da mesma amostra, as imagens da mesma amostra devem compartilhar o mesmo prefixo de nome de arquivo, que é definido como a parte do nome do arquivo que precede o primeiro hífen (`-`) ou underscore (`_`). Então, ao usar `get_measures()`, as medidas das imagens de folhas chamadas, por exemplo, `F1-1.jpeg`,` F1_2.jpeg` e `F1-3.jpeg` serão combinadas em uma única imagem (`F1`), mostrado no objeto `merge`. Isso é útil, por exemplo, para analisar folhas grandes que precisam ser divididas em várias imagens ou várias folhas pertencentes à mesma amostra que não podem ser digitalizadas em uma imagem única.

No exemplo a seguir, cinco imagens serão usadas como exemplos. Cada imagem possui folhas de diferentes espécies. As imagens foram divididas em imagens diferentes que compartilham o mesmo prefixo (por exemplo, L1_\*, L2_\* e assim por diante). Observe que para garantir que todas as imagens sejam processadas, todas as imagens devem compartilhar um padrão comum, neste caso ("L"). Os três pontos no canto inferior direito têm uma distância conhecida de 5 cm entre eles, que pode ser usada para extrair o dpi da imagem com `dpi()`. Apenas para fins didáticos, considerarei que todas as imagens têm resolução de 100 dpi.


```{r merge0, fig.width = 10, fig.height = 10}
# imagens inteiras
imgs <-
  image_import(pattern = "leaf",
               plot = TRUE,
               ncol = 2)

# imagens da mesma amostra
sample_imgs <-
  image_import(pattern = "L",
               plot = TRUE,
               ncol = 5)
```

Aqui, usarei o `pattern =" L "` para indicar que todas as imagens com este nome de padrão devem ser analisadas. O índice verde (`" G "`) é usado para segmentar as folhas e `divisor de águas = FALSO` é usado para omitir o algoritmo de segmentação de divisor de águas.


```{r merge1}
merged <-
  analyze_objects(pattern = "L",
                  index = "B",
                  watershed = FALSE)
```

Usando a função `get_measures()` é possível converter as medidas de unidades de pixel em unidades métricas (cm$^ 2$).

```{r merge2}
merged_cor <- get_measures(merged, dpi = 100)
```

Observe que o `merged_cor` é uma lista com três objetos:

* `results`: um data frame que contém as medidas de cada objeto individual (neste caso, folha) de cada imagem analisada.

```{r merge3}
merged_cor$results
```

* `summary`: um data frame que contém o resumo dos resultados, contendo o número de objetos em cada imagem (`n`) a soma, média e desvio padrão da área de cada imagem, bem como o valor médio para todas as outras medidas (perímetro, raio, etc.)


```{r merge4}
merged_cor$summary
```

* `merge`: um data frame que contém os resultados mesclados pelo prefixo da imagem. Observe que, neste caso, os resultados são apresentados por L1, L2, L3, L4 e L5.

```{r merge5}
merged_cor$merge
```

O `area_sum` de img` L1` é a soma das duas folhas (uma em cada imagem)

```{r merge6}
sum(merged_cor$results$area[1:2])
```




```{r merge9, fig.width=10, fig.height=5}
df_leaf <-
  merged_cor$results %>% 
  separate(img, into = c("img", "code"))

# leaf area of the different species
p1 <- 
  ggplot(df_leaf, aes(x = img, y = area)) +
  geom_boxplot() +
  geom_jitter(color = "red") +
  labs(x = "Imagem", y = expression(Área~(cm^2)))

p2 <- 
  ggplot(df_leaf, aes(x = img, y = area)) +
  stat_summary(fun = sum,
               geom = "bar",
               col = "black") +
  labs(x = "Imagem", y = expression(Área~total~(cm^2)))


# solidity of the different species
p3 <- 
  ggplot(df_leaf, aes(x = img, y = solidity)) +
  geom_boxplot() +
  geom_jitter(color = "red") +
  labs(x = "Imagem", y = "Solidez")

p1 + p2 + p3 +
  plot_layout(ncol = 3)
```


# Valores RGB para cada objeto

Para obter a intensidade RGB de cada objeto de imagem, usamos o argumento `object_rgb = TRUE` na função `analyze_objects() `. Neste exemplo,

```{r rgb1, fig.width = 10, fig.height = 10}
img <- image_import("soy1.jpeg", plot = TRUE)


```

A média dos valores da banda verde será calculada declarando `object_index = "G"`.

```{r rgb2, fig.width = 10, fig.height = 10}
soy_green <-
  analyze_objects(img,
                  object_index = "R",
                  marker_col = "black",
                  col_background = "white",
                  show_contour = FALSE)

plot_measures(soy_green,
              measure = "R",
              col = "black")
```


Parece que grãos com valores médios de verde (R) inferiores a 0.6 podem ser consideradas sementes esverdeadas. Os usuários podem então trabalhar com esse recurso e adaptá-lo ao seu caso.

```{r rgb4}
report <- summary_index(soy_green, index = "R", cut_point = 0.6)
ids <- report$ids

plot(img)
plot_measures(soy_green,
              id = ids,
              measure = "R",
              col = "black")
cont <- object_contour(img, show_image = FALSE)
plot_contour(cont, id = ids, col = "red")
```



Quando existem muitos objetos, o argumento `parallel = TRUE` irá acelerar a extração dos valores RGB. No exemplo a seguir, uma imagem com 1343 grãos de *Vicia cracca* é analisada. Os índices `"R"` e `"R/G"` são computados. Os grãos com um valor médio de vermelho superior a 0,25 são destacados.

```{r rgb5, fig.width = 12, fig.height=10}
img2 <- image_import("vicia.jpg", plot = TRUE)

vicia <-
  analyze_objects(img2,
                  index = "B",
                  object_index = "R",
                  show_image = FALSE,
                  parallel = TRUE)

resumo_indice <- 
  summary_index(vicia,
                index = "R",
                cut_point = 0.25,
                select_higher = TRUE)

cont2 <-
  object_contour(img2,
                 index = "B",
                 show_image = FALSE)
ids2 <- resumo_indice$ids
plot_contour(cont2, id = ids2, col = "red")


# cria gráfico de densidade dos valores RGB para as duas classes de grãos
rgbs <-
  vicia$object_rgb %>%
  mutate(type = ifelse(id %in% ids2, "Destacado", "Não destacado")) %>%
  select(-id) %>%
  pivot_longer(-type)

ggplot(rgbs, aes(x = value)) +
  geom_density(aes(fill = name), alpha = 0.5) +
  facet_wrap(~type)
```



# Severidade de doenças
## Utilizando paletas

```{r doença1, fig.width = 12, fig.height = 3, collapse=TRUE}

img <- image_import("soy_1.jpg")
h <- image_import("sev_healthy.png")
d <- image_import("sev_disease.png")
b <- image_import("sev_back.png")
image_combine(img, h, d, b, ncol = 4)
```

## Gerando paletas
```{r eval=FALSE, fig.width=10}
b2 <- pick_palette(img)
h2 <- pick_palette(img)
d2 <- pick_palette(img)
image_combine(h2, d2, b2, ncol = 3)

```


## Padrão da função
```{r}
sev <- 
  measure_disease(img = img,
                  img_healthy = h,
                  img_symptoms = d,
                  img_background = b)
sev$severity
```


## Mostrando preenchimento das lesões
```{r}
sev <- 
  measure_disease(img = img,
                  img_healthy = h,
                  img_symptoms = d,
                  img_background = b,
                  show_contour = FALSE)
```


## Mostrando uma máscara
```{r}
sev <- 
  measure_disease(img = img,
                  img_healthy = h,
                  img_symptoms = d,
                  img_background = b,
                  show_contour = FALSE,
                  show_original = FALSE,
                  col_lesions = "brown")
```


## Segmentando e analizando lesões
```{r}
sev <- 
  measure_disease(img = img,
                  img_healthy = h,
                  img_symptoms = d,
                  img_background = b,
                  watershed = TRUE,
                  lesion_size = "elarge",
                  show_contour = FALSE, # não mostra os contornos
                  show_features = TRUE, # computa características das lesões
                  show_segmentation = TRUE) # mostra as segmentações
sev$severity

sev$statistics
sev$shape[1:10, ]
```



## Utilizando índices RGB
Para identificar o melhor índice para segmentar a imagem do fundo e após as lesões da folha sadia, pode-se utilizar a função `image_segment_iter`. (OBS. somente funcionará em uma seção iterativa).


```{r eval=FALSE}
img %>% 
  image_resize(50) %>% 
  image_segment_iter(nseg = 2, ncol = 3)

```

Após escolhidos os índices, podemos utilizar os argumentos `index_lb` e `index_dh` para segmentação da folha e fundo | lesão e sadio, respectivamente.

```{r}
# após escolhidos os índices, utiliza
sev_index <- 
  measure_disease(img, 
                  index_lb = "G",
                  index_dh = "GLAI",
                  threshold = c("Otsu", 0.5),
                  show_image = TRUE)
sev_index$severity
```



## Processamento em lote
Para analisar diversas imagens de um diretório, utiliza-se o argumento `pattern`, para declarar um padrão de nomes de arquivos. Serão utilizadas 20 folhas de soja disponíveis no repositório  https://osf.io/4hbr6, um banco de dados de imagens de anotação de severidade de doenças de plantas. Obrigado a [Emerson M. Del Ponte](https://osf.io/jb6yd/) e seus colaboradores por manter este projeto disponível publicamente.

```{r}
system.time(
  sev_lote <- 
    measure_disease(pattern = "soy_",
                    img_healthy = "sev_healthy",
                    img_symptoms = "sev_disease",
                    img_background = "sev_back",
                    col_lesions = "brown",
                    show_contour = FALSE,
                    show_image = FALSE,
                    save_image = TRUE,
                    dir_processed = "processed",
                    parallel = TRUE)
)
sev_lote$severity
```

## Imagens processadas
```{r fig.width=10, fig.height=10}
imgs <- 
  image_import(pattern = "proc_",
               path = "processed",
               plot = TRUE,
               ncol = 5)
```



## Diagramas de área padrão

Os diagramas de área padrão (SAD) têm sido usados há muito tempo como uma ferramenta para auxiliar na estimativa da severidade de doenças de plantas, servindo como um modelo de referência padrão antes ou durante as avaliações.

Dado um objeto calculado com `measure_disease()`, um SAD com `n` imagens contendo os respectivos valores de severidade é obtido com `sad()`.

As folhas com menor e maior severidade sempre estarão no SAD. Se `n = 1`, a folha com a menor severidade será retornada. As outras são amostradas sequencialmente para obter as `n` imagens após a severidade ter sido ordenada em ordem crescente. Por exemplo, se houver 30 folhas e `n` for definido como 3, as folhas amostradas serão a 1ª, 15ª e 30ª com os menores valores de severidade.

O SAD só pode ser calculado se um nome de padrão de imagem for usado no argumento `pattern` da função `measure_disease()`. Se as imagens forem salvas, as `n` imagens serão recuperadas do diretório `dir_processed` (diretório padrão por default). Caso contrário, a severidade será calculada novamente para gerar as imagens. Um SAD com 8 imagens do exemplo acima pode ser obtido facilmente com:

```{r}
sad(sev_lote, n = 8, ncol = 4)
```


## Múltiplas folhas em uma foto

Quando múltiplas folhas estão presentes em uma imagem, a função `measure_disease` retorna a severidade média das folhas presentes na imagem. Para quantificar a severidade *por folha*, a função `measure_disease_byl()` pode ser utilizada.

Esta função calcula a porcentagem de área foliar sintomática usando paletas de cores ou índices RGB para cada folha (`byl`) de uma imagem. Isso permite, por exemplo, processar réplicas do mesmo tratamento e obter os resultados de cada replicação com uma única imagem. Para fazer isso, as amostras de folhas são primeiro divididas usando a função `object_split()` e, em seguida, a função `measure_disease()` é aplicado à lista de folhas.

```{r}
mult1 <- image_import("multiplas_01.jpeg", plot = TRUE)
image_index(mult1)

# 
byl <- 
  measure_disease_byl(pattern = "multiplas_",
                      index = "B", # usado para segmentar a folha do fundo
                      img_healthy = "sev_healthy",
                      img_symptoms = "sev_disease",
                      show_contour = FALSE,
                      col_lesions = "red")
byl$severity
```





